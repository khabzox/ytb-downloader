import ytdl from "ytdl-core";
// Alternative import - try this if main ytdl-core fails
import ytdlDistube from "@distube/ytdl-core";
import { extractYouTubeVideoId, isYouTubeShort } from "./validators";

// Enhanced Types with future options
export interface YouTubeVideoInfo {
  id: string;
  title: string;
  thumbnail: string;
  duration: string;
  views: string;
  likes: string;
  uploadDate: string;
  description: string;
  isShort?: boolean;
  category?: string;
  tags?: string[];
  language?: string;
  channel: {
    name: string;
    avatar: string;
    subscribers: string;
    verified: boolean;
    bio?: string;
    socialLinks?: {
      youtube?: string;
      twitter?: string;
      website?: string;
      instagram?: string;
      tiktok?: string;
    };
    channelId?: string;
    joinDate?: string;
    location?: string;
  };
  // Future options
  analytics?: {
    engagement?: string;
    avgViewDuration?: string;
    topCountries?: string[];
    ageGroup?: string;
  };
  chapters?: Array<{
    title: string;
    startTime: number;
    thumbnail?: string;
  }>;
  subtitles?: Array<{
    language: string;
    url: string;
    autoGenerated: boolean;
  }>;
}

export interface DownloadFormat {
  type: "MP4" | "WEBM" | "MP3" | "M4A" | "MKV" | "FLAC";
  quality: string;
  size: string;
  itag?: number;
  url?: string;
  hasAudio: boolean;
  hasVideo: boolean;
  recommended?: boolean;
  bitrate?: number;
  fps?: number;
  // Future options
  hdr?: boolean;
  codec?: string;
  container?: string;
  audioChannels?: number;
  sampleRate?: number;
  downloadSpeed?: string;
  estimatedTime?: string;
}

export interface YouTubeApiOptions {
  // Current options
  includeFormats?: boolean;
  maxFormats?: number;
  preferredQuality?: "highest" | "lowest" | "medium";
  audioOnly?: boolean;
  videoOnly?: boolean;

  // Future options
  includeSubtitles?: boolean;
  includeChapters?: boolean;
  includeAnalytics?: boolean;
  includeThumbnails?: boolean;
  cacheResults?: boolean;
  cacheDuration?: number; // in minutes
  proxy?: string;
  userAgent?: string;
  region?: string;
  language?: string;
  format?: "json" | "xml" | "csv";
  compression?: boolean;
  thumbnailSizes?: ("default" | "medium" | "high" | "maxres")[];
}

export interface YouTubeApiResponse {
  success: boolean;
  data?: {
    videoInfo: YouTubeVideoInfo;
    downloadOptions: DownloadFormat[];
  };
  error?: string;
  errorType?:
    | "YTDL_FUNCTIONS"
    | "UNAVAILABLE"
    | "RESTRICTED"
    | "NETWORK"
    | "UNKNOWN"
    | "RATE_LIMITED"
    | "REGION_BLOCKED";
  metadata?: {
    processingTime: number;
    apiVersion: string;
    cached?: boolean;
    region?: string;
    timestamp: string;
  };
}

// Enhanced error handling class
class YouTubeError extends Error {
  constructor(
    message: string,
    public type: YouTubeApiResponse["errorType"] = "UNKNOWN",
    public statusCode?: number,
    public retryAfter?: number,
  ) {
    super(message);
    this.name = "YouTubeError";
  }
}

// Enhanced helper functions
function formatDuration(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const remainingSeconds = seconds % 60;

  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(2, "0")}:${remainingSeconds.toString().padStart(2, "0")}`;
  }
  return `${minutes}:${remainingSeconds.toString().padStart(2, "0")}`;
}

function formatNumber(num: string | number): string {
  const number = typeof num === "string" ? parseInt(num, 10) : num;
  if (isNaN(number)) return "0";

  if (number >= 1_000_000_000) {
    return `${(number / 1_000_000_000).toFixed(1)}B`;
  } else if (number >= 1_000_000) {
    return `${(number / 1_000_000).toFixed(1)}M`;
  } else if (number >= 1_000) {
    return `${(number / 1_000).toFixed(1)}K`;
  }
  return number.toLocaleString();
}

function formatViews(num: string | number): string {
  const number = typeof num === "string" ? parseInt(num, 10) : num;
  if (isNaN(number)) return "0";
  return number.toLocaleString();
}

function formatFileSize(bytes: number): string {
  if (bytes === 0) return "0 B";
  const k = 1024;
  const sizes = ["B", "KB", "MB", "GB", "TB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
}

function getBestThumbnail(thumbnails: Array<{ url: string }>): string {
  const preferredOrder = ["maxresdefault", "hqdefault", "mqdefault", "default"];
  for (const quality of preferredOrder) {
    const thumbnail = thumbnails.find(t => t.url.includes(quality));
    if (thumbnail) return thumbnail.url;
  }
  return thumbnails[0]?.url || "";
}

function getQualityLabel(format: { qualityLabel?: string; height?: number; audioBitrate?: number }): string {
  if (format.qualityLabel) return format.qualityLabel;
  if (format.height) return `${format.height}p`;
  if (format.audioBitrate) return `${format.audioBitrate}kbps`;
  return "Unknown";
}

function formatUploadDate(dateString: string): string {
  try {
    const date = new Date(dateString);
    return date.toISOString().split("T")[0];
  } catch {
    return new Date().toISOString().split("T")[0];
  }
}

// Enhanced error messages
function getUserFriendlyError(error: unknown): {
  message: string;
  type: YouTubeApiResponse["errorType"];
  retryAfter?: number;
} {
  const errorMessage = (error as Error)?.message?.toLowerCase() || "";

  if (errorMessage.includes("could not extract functions")) {
    return {
      message:
        "YouTube has updated their system. Please try again in a few minutes, or check back later for an app update.",
      type: "YTDL_FUNCTIONS",
    };
  }

  if (errorMessage.includes("rate limit") || (error as any).statusCode === 429) {
    return {
      message: "Too many requests. Please wait a moment before trying again.",
      type: "RATE_LIMITED",
      retryAfter: 60,
    };
  }

  if ((error as any).statusCode === 410 || errorMessage.includes("video unavailable")) {
    return {
      message: "This video is no longer available or has been removed.",
      type: "UNAVAILABLE",
    };
  }

  if ((error as any).statusCode === 451 || errorMessage.includes("region")) {
    return {
      message: "This video is not available in your region.",
      type: "REGION_BLOCKED",
    };
  }

  if (
    (error as any).statusCode === 403 ||
    errorMessage.includes("private") ||
    errorMessage.includes("restricted")
  ) {
    return {
      message: "This video is private, restricted, or not available in your region.",
      type: "RESTRICTED",
    };
  }

  if (errorMessage.includes("network") || errorMessage.includes("timeout")) {
    return {
      message: "Network error. Please check your connection and try again.",
      type: "NETWORK",
    };
  }

  return {
    message:
      "Unable to fetch video information. This may be due to YouTube updates or temporary issues.",
    type: "UNKNOWN",
  };
}

// Enhanced fallback method
async function getFallbackVideoInfo(videoId: string): Promise<Partial<YouTubeVideoInfo>> {
  try {
    const thumbnailUrl = `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`;

    return {
      id: videoId,
      title: "Video information temporarily unavailable",
      thumbnail: thumbnailUrl,
      duration: "Unknown",
      views: "0",
      likes: "0",
      uploadDate: formatUploadDate(new Date().toISOString()),
      description: "Video details are temporarily unavailable due to YouTube updates.",
      isShort: false,
      channel: {
        name: "Unknown Channel",
        avatar: "",
        subscribers: "0",
        verified: false,
      },
    };
  } catch {
    throw new YouTubeError("Unable to create fallback video info", "UNKNOWN");
  }
}

/**
 * Enhanced main function with better error handling and expected data structure
 */
export async function getYouTubeVideoData(
  url: string,
  options: YouTubeApiOptions = {},
): Promise<YouTubeApiResponse> {
  const startTime = Date.now();

  try {
    const videoId = extractYouTubeVideoId(url);
    if (!videoId) {
      return {
        success: false,
        error: "Invalid YouTube URL or could not extract video ID",
        errorType: "UNKNOWN",
      };
    }

    // Default options
    const defaultOptions: YouTubeApiOptions = {
      includeFormats: true,
      maxFormats: 10,
      preferredQuality: "highest",
      includeSubtitles: false,
      includeChapters: false,
      includeAnalytics: false,
      ...options,
    };

    // First, try to validate the URL
    let isValid: boolean;
    try {
      isValid = await Promise.race([
        ytdl.validateURL(url),
        new Promise<boolean>((_, reject) =>
          setTimeout(() => reject(new Error("Validation timeout")), 10000),
        ),
      ]);
    } catch (validationError: unknown) {
      console.warn("URL validation failed, attempting to continue:", (validationError as Error).message);
      isValid = true;
    }

    if (!isValid) {
      return {
        success: false,
        error: "Video is not available or accessible",
        errorType: "UNAVAILABLE",
      };
    }

    // Try to get video info with fallback mechanism
    let info: unknown;
    let usedFallback = false;
    
    try {
      // First try with main ytdl-core
      info = await Promise.race([
        ytdl.getInfo(videoId),
        new Promise((_, reject) => setTimeout(() => reject(new Error("Request timeout")), 30000)),
      ]);
    } catch (infoError: unknown) {
      if (typeof infoError === "object" && infoError && "message" in infoError && typeof (infoError as { message: unknown }).message === "string") {
        const msg = (infoError as { message: string }).message;
        if (msg.includes("Could not extract functions") || msg.includes("could not extract functions")) {
          try {
            console.log("Trying fallback with @distube/ytdl-core...");
            info = await Promise.race([
              ytdlDistube.getInfo(videoId),
              new Promise((_, reject) => setTimeout(() => reject(new Error("Fallback request timeout")), 30000)),
            ]);
            usedFallback = true;
            console.log("Successfully got video info with @distube/ytdl-core");
          } catch (fallbackError: unknown) {
            console.error("Failed to get video info with fallback ytdl:", fallbackError);
            
            // If both fail, provide limited fallback info
            try {
              const fallbackInfo = await getFallbackVideoInfo(videoId);
              return {
                success: true,
                data: {
                  videoInfo: fallbackInfo as YouTubeVideoInfo,
                  downloadOptions: [
                    {
                      type: "MP4" as const,
                      quality: "1080p",
                      size: "Unknown",
                      hasAudio: true,
                      hasVideo: true,
                      recommended: true,
                    },
                  ],
                },
                error: "Limited information available due to YouTube updates",
                metadata: {
                  processingTime: Date.now() - startTime,
                  apiVersion: "1.0.0",
                  timestamp: new Date().toISOString(),
                },
              };
            } catch {
              // Complete fallback failed
            }
          }
        }
      }
      
      // If it's not a functions error or fallback also failed
      if (!usedFallback) {
        const { message, type, retryAfter } = getUserFriendlyError(infoError as Error);
        return {
          success: false,
          error: message,
          errorType: type,
          metadata: {
            processingTime: Date.now() - startTime,
            apiVersion: "1.0.0",
            timestamp: new Date().toISOString(),
          },
        };
      }
    }

    const videoDetails = (info as any).videoDetails;
    const formats = (info as any).formats || [];
    const isShort = isYouTubeShort(url);

    // Parse video information with enhanced data structure
    const videoInfo: YouTubeVideoInfo = {
      id: videoId,
      title: videoDetails.title || "Unknown Title",
      thumbnail: getBestThumbnail(videoDetails.thumbnails || []),
      duration: formatDuration(parseInt(videoDetails.lengthSeconds || "0", 10)),
      views: formatViews(videoDetails.viewCount || "0"),
      likes: formatNumber(videoDetails.likes || "0"),
      uploadDate: formatUploadDate(videoDetails.uploadDate || videoDetails.publishDate),
      description: videoDetails.description || "",
      isShort,
      category: videoDetails.category || undefined,
      tags: videoDetails.keywords || undefined,
      language: videoDetails.language || undefined,
      channel: {
        name: videoDetails.author?.name || "Unknown Channel",
        avatar: videoDetails.author?.thumbnails?.[0]?.url || "",
        subscribers: formatNumber(videoDetails.author?.subscriber_count || "0"),
        verified: videoDetails.author?.verified || false,
        bio: (videoDetails.author as any)?.description || undefined,
        channelId: videoDetails.author?.id || undefined,
        socialLinks: {
          youtube: videoDetails.author?.channel_url,
        },
      },
    };

    // Process download formats with enhanced structure
    const downloadOptions: DownloadFormat[] = [];

    if (defaultOptions.includeFormats && !defaultOptions.audioOnly) {
      try {
        // Video formats (MP4) - matching your expected structure
        const videoFormats = formats.filter(
          (format: any) => format.hasVideo && format.container === "mp4" && format.qualityLabel,
        );

        videoFormats.sort((a: any, b: any) => {
          const heightA = parseInt(a.qualityLabel?.replace("p", "") || "0", 10);
          const heightB = parseInt(b.qualityLabel?.replace("p", "") || "0", 10);
          return heightB - heightA;
        });

        const addedQualities = new Set<string>();
        videoFormats.forEach((format: any, index: number) => {
          const quality = getQualityLabel(format);
          if (
            !addedQualities.has(quality) &&
            downloadOptions.length < (defaultOptions.maxFormats || 10)
          ) {
            addedQualities.add(quality);
            downloadOptions.push({
              type: "MP4",
              quality,
              size: format.contentLength
                ? formatFileSize(parseInt(format.contentLength, 10))
                : "Unknown",
              itag: format.itag,
              url: format.url,
              hasAudio: format.hasAudio || false,
              hasVideo: format.hasVideo || false,
              recommended: index === 0,
              fps: format.fps,
              hdr: format.colorInfo?.primaries === "bt2020" || false,
              codec: format.codecs,
              container: format.container,
            });
          }
        });
      } catch (formatError) {
        console.error("Error processing video formats:", formatError);
      }
    }

    if (defaultOptions.includeFormats && !defaultOptions.videoOnly) {
      try {
        // Audio formats - matching your expected structure
        const audioFormats = formats.filter((format: any) => format.hasAudio && !format.hasVideo);
        audioFormats.sort((a: any, b: any) => (b.audioBitrate || 0) - (a.audioBitrate || 0));

        const addedAudioQualities = new Set<string>();
        audioFormats.forEach((format: any) => {
          const quality = `${format.audioBitrate}kbps`;
          if (
            !addedAudioQualities.has(quality) &&
            format.audioBitrate &&
            downloadOptions.length < (defaultOptions.maxFormats || 10)
          ) {
            addedAudioQualities.add(quality);
            let formatType: "MP3" | "WEBM" | "M4A" | "MP4" = "MP3";
            if (format.container === "webm") formatType = "WEBM";
            else if (format.container === "mp4") formatType = "M4A";

            downloadOptions.push({
              type: formatType,
              quality,
              size: format.contentLength
                ? formatFileSize(parseInt(format.contentLength, 10))
                : "Unknown",
              itag: format.itag,
              url: format.url,
              hasAudio: true,
              hasVideo: false,
              bitrate: format.audioBitrate,
              codec: format.codecs,
              container: format.container,
              audioChannels: format.audioChannels,
              sampleRate: format.audioSampleRate,
            });
          }
        });
      } catch (formatError) {
        console.error("Error processing audio formats:", formatError);
      }
    }

    // Fallback formats if none found - matching your expected structure
    if (downloadOptions.length === 0) {
      downloadOptions.push(
        {
          type: "MP4",
          quality: "1080p",
          size: "Unknown",
          hasAudio: true,
          hasVideo: true,
          recommended: true,
        },
        {
          type: "MP4",
          quality: "720p",
          size: "Unknown",
          hasAudio: true,
          hasVideo: true,
          recommended: false,
        },
        {
          type: "MP3",
          quality: "320kbps",
          size: "Unknown",
          hasAudio: true,
          hasVideo: false,
          recommended: false,
        },
      );
    }

    return {
      success: true,
      data: {
        videoInfo,
        downloadOptions,
      },
      metadata: {
        processingTime: Date.now() - startTime,
        apiVersion: "1.0.0",
        timestamp: new Date().toISOString(),
      },
    };
  } catch (error: unknown) {
    console.error("YouTube API Error:", error);
    const { message, type } = getUserFriendlyError(error as Error);

    return {
      success: false,
      error: message,
      errorType: type,
      metadata: {
        processingTime: Date.now() - startTime,
        apiVersion: "1.0.0",
        timestamp: new Date().toISOString(),
      },
    };
  }
}

/**
 * Enhanced basic info function with timeout and better formatting
 */
export async function getVideoBasicInfo(url: string): Promise<{
  success: boolean;
  title?: string;
  thumbnail?: string;
  duration?: string;
  error?: string;
  errorType?: YouTubeApiResponse["errorType"];
}> {
  try {
    const videoId = extractYouTubeVideoId(url);
    if (!videoId) {
      return {
        success: false,
        error: "Invalid YouTube URL",
        errorType: "UNKNOWN",
      };
    }

    let basicInfo: unknown;
    let usedFallback = false;

    try {
      // First try with main ytdl-core
      basicInfo = await Promise.race([
        ytdl.getBasicInfo(videoId),
        new Promise((_, reject) => setTimeout(() => reject(new Error("Request timeout")), 15000)),
      ]);
    } catch (infoError: unknown) {
      if (typeof infoError === "object" && infoError && "message" in infoError && typeof (infoError as { message: unknown }).message === "string") {
        const msg = (infoError as { message: string }).message;
        if (msg.includes("Could not extract functions") || msg.includes("could not extract functions")) {
          try {
            console.log("Trying fallback with @distube/ytdl-core for basic info...");
            basicInfo = await Promise.race([
              ytdlDistube.getBasicInfo(videoId),
              new Promise((_, reject) => setTimeout(() => reject(new Error("Fallback request timeout")), 15000)),
            ]);
            usedFallback = true;
            console.log("Successfully got basic info with @distube/ytdl-core");
          } catch (fallbackError: unknown) {
            console.error("Failed to get basic info with fallback ytdl:", fallbackError);
            throw fallbackError;
          }
        } else {
          throw infoError;
        }
      } else {
        throw infoError;
      }
    }

    const videoDetails = (basicInfo as any).videoDetails;

    return {
      success: true,
      title: videoDetails?.title || "Unknown Title",
      thumbnail: getBestThumbnail(videoDetails?.thumbnails || []),
      duration: formatDuration(parseInt(videoDetails?.lengthSeconds || "0", 10)),
    };
  } catch (error: unknown) {
    console.error("Basic info error:", error);
    const { message, type } = getUserFriendlyError(error as Error);

    return {
      success: false,
      error: message,
      errorType: type,
    };
  }
}

/**
 * Enhanced health check function
 */
export async function checkYtdlHealth(): Promise<{
  isWorking: boolean;
  error?: string;
  suggestion?: string;
  performance?: {
    responseTime: number;
    apiVersion: string;
  };
}> {
  const startTime = Date.now();

  try {
    const testVideoId = "dQw4w9WgXcQ"; // Rick Roll - always available for testing
    const testUrl = `https://www.youtube.com/watch?v=${testVideoId}`;

    // First try with main ytdl-core
    try {
      const result = await Promise.race([
        ytdl.validateURL(testUrl),
        new Promise<boolean>((_, reject) =>
          setTimeout(() => reject(new Error("Health check timeout")), 10000),
        ),
      ]);

      if (result) {
        return {
          isWorking: true,
          performance: {
            responseTime: Date.now() - startTime,
            apiVersion: "1.0.0 (ytdl-core)",
          },
        };
      }
    } catch (mainError: unknown) {
      console.log("Main ytdl-core health check failed, trying @distube/ytdl-core...");
      
      // If main fails, try with distube
      try {
        const distubeResult = await Promise.race([
          ytdlDistube.validateURL(testUrl),
          new Promise<boolean>((_, reject) =>
            setTimeout(() => reject(new Error("Distube health check timeout")), 10000),
          ),
        ]);

        if (distubeResult) {
          return {
            isWorking: true,
            performance: {
              responseTime: Date.now() - startTime,
              apiVersion: "1.0.0 (@distube/ytdl-core)",
            },
          };
        }
      } catch (distubeError: unknown) {
        console.error("Both ytdl libraries failed health check:", { mainError, distubeError });
      }
    }

    return {
      isWorking: false,
      error: "YouTube validation failed with both libraries",
      suggestion: "Both ytdl-core and @distube/ytdl-core are having issues. Try again later.",
    };
  } catch (error: unknown) {
    const { message, type } = getUserFriendlyError(error as Error);

    let suggestion = "Try again later";
    if (type === "YTDL_FUNCTIONS") {
      suggestion = "Both ytdl libraries are having issues. Try again later or check for updates.";
    }

    return {
      isWorking: false,
      error: message,
      suggestion,
    };
  }
}

// Enhanced utility functions
export async function getDownloadUrl(
  videoId: string,
  itag: number,
): Promise<{ success: boolean; url?: string; error?: string; metadata?: any }> {
  try {
    let info: unknown;
    let usedFallback = false;

    try {
      // First try with main ytdl-core
      info = await ytdl.getInfo(videoId);
    } catch (infoError: unknown) {
      if (typeof infoError === "object" && infoError && "message" in infoError && typeof (infoError as { message: unknown }).message === "string") {
        const msg = (infoError as { message: string }).message;
        if (msg.includes("Could not extract functions") || msg.includes("could not extract functions")) {
          try {
            console.log("Trying fallback with @distube/ytdl-core for download...");
            info = await ytdlDistube.getInfo(videoId);
            usedFallback = true;
          } catch (fallbackError: unknown) {
            throw fallbackError;
          }
        } else {
          throw infoError;
        }
      } else {
        throw infoError;
      }
    }

    const format = (info as any).formats.find((f: any) => f.itag === itag);

    if (!format) {
      return {
        success: false,
        error: "Format not found",
      };
    }

    return {
      success: true,
      url: format.url,
      metadata: {
        quality: getQualityLabel(format),
        size: format.contentLength ? formatFileSize(parseInt(format.contentLength, 10)) : "Unknown",
        container: format.container,
        codecs: format.codecs,
      },
    };
  } catch (error: unknown) {
    const { message } = getUserFriendlyError(error as Error);
    return {
      success: false,
      error: message,
    };
  }
}

export function createVideoStream(url: string, options?: ytdl.downloadOptions) {
  try {
    return ytdl(url, {
      quality: "highest",
      filter: "audioandvideo",
      ...options,
    });
  } catch (error: unknown) {
    // If main ytdl fails, try with distube
    if (typeof error === "object" && error && "message" in error && typeof (error as Error).message === "string") {
      const msg = (error as Error).message;
      if (msg.includes("Could not extract functions")) {
        console.log("Using @distube/ytdl-core for video stream...");
        const distubeOptions = { ...options } as any;
        return ytdlDistube(url, {
          quality: "highest" as any,
          filter: "audioandvideo" as any,
          ...distubeOptions,
        });
      }
    }
    throw error;
  }
}

export function createAudioStream(url: string, options?: ytdl.downloadOptions) {
  try {
    return ytdl(url, {
      quality: "highestaudio",
      filter: "audioonly",
      ...options,
    });
  } catch (error: unknown) {
    // If main ytdl fails, try with distube
    if (typeof error === "object" && error && "message" in error && typeof (error as Error).message === "string") {
      const msg = (error as Error).message;
      if (msg.includes("Could not extract functions")) {
        console.log("Using @distube/ytdl-core for audio stream...");
        const distubeOptions = { ...options } as any;
        return ytdlDistube(url, {
          quality: "highestaudio" as any,
          filter: "audioonly" as any,
          ...distubeOptions,
        });
      }
    }
    throw error;
  }
}

export function createVideoStreamWithFallback(url: string, options?: ytdl.downloadOptions): NodeJS.ReadableStream {
  try {
    return ytdl(url, { quality: "highest", filter: "audioandvideo", ...options });
  } catch (err) {
    if (err instanceof Error && err.message?.includes("Could not extract functions")) {
      // Only copy allowed properties for distube
      const distubeOptions: Record<string, unknown> = {};
      if (options?.range) distubeOptions.range = options.range;
      if (options?.begin) distubeOptions.begin = options.begin;
      if (options?.liveBuffer) distubeOptions.liveBuffer = options.liveBuffer;
      if (options?.highWaterMark) distubeOptions.highWaterMark = options.highWaterMark;
      if (options?.IPv6Block) distubeOptions.IPv6Block = options.IPv6Block;
      if (options?.dlChunkSize) distubeOptions.dlChunkSize = options.dlChunkSize;
      if (options?.requestOptions) distubeOptions.requestOptions = options.requestOptions;
      if (options?.lang) distubeOptions.lang = options.lang;
      if (options?.format) {/* skip */}
      if (options?.quality) {/* skip */}
      if (options?.filter) {/* skip */}
      return ytdlDistube(url, {
        ...distubeOptions,
        quality: "highest",
        filter: "audioandvideo",
      });
    }
    throw err;
  }
}

// Future-ready utility functions
export async function getVideoChapters(_videoId: string): Promise<unknown[]> {
  return [];
}
export async function getVideoSubtitles(_videoId: string, _language?: string): Promise<unknown[]> {
  return [];
}
export async function getVideoAnalytics(_videoId: string): Promise<unknown> {
  return null;
}

// Export default options for easy configuration
export const defaultApiOptions: YouTubeApiOptions = {
  includeFormats: true,
  maxFormats: 10,
  preferredQuality: "highest",
  audioOnly: false,
  videoOnly: false,
  includeSubtitles: false,
  includeChapters: false,
  includeAnalytics: false,
  includeThumbnails: true,
  cacheResults: false,
  cacheDuration: 30,
};
